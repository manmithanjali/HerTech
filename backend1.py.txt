from fastapi import FastAPI, APIRouter, HTTPException
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Optional, Dict
import uuid
from datetime import datetime, timezone
from emergentintegrations.llm.chat import LlmChat, UserMessage
import json

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# Create the main app without a prefix
app = FastAPI()

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")

# LLM Configuration
EMERGENT_LLM_KEY = os.environ.get('EMERGENT_LLM_KEY')

# ==================== MODELS ====================

class UserProfile(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    age: int
    weight: float  # in kg
    height: float  # in cm
    gender: str  # male/female
    conditions: List[str] = []  # health conditions
    goals: List[str] = []  # fitness goals
    created_at: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

class ProfileCreate(BaseModel):
    name: str
    age: int
    weight: float
    height: float
    gender: str
    conditions: List[str] = []
    goals: List[str] = []

class ProfileUpdate(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None
    weight: Optional[float] = None
    height: Optional[float] = None
    gender: Optional[str] = None
    conditions: Optional[List[str]] = None
    goals: Optional[List[str]] = None

class Exercise(BaseModel):
    name: str
    sets: int
    reps: str
    rest: str
    instructions: str

class DailyWorkout(BaseModel):
    day: int
    exercises: List[Exercise]
    focus: str  # e.g., "Upper Body", "Cardio"

class DailyMeal(BaseModel):
    day: int
    breakfast: str
    lunch: str
    dinner: str
    snacks: List[str]
    total_calories: int
    protein: float
    carbs: float
    fat: float

class WorkoutPlan(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    profile_id: str
    duration_days: int
    daily_workouts: List[DailyWorkout]
    created_at: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

class NutritionPlan(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    profile_id: str
    duration_days: int
    daily_meals: List[DailyMeal]
    created_at: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

class PlanGenerationRequest(BaseModel):
    profile_id: str
    duration_days: int = 7
    workout_intensity: str = "medium"  # low/medium/high
    include_workout: bool = True
    include_nutrition: bool = True

class ProgressLog(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    profile_id: str
    plan_id: str
    day: int
    exercise_name: str
    completed: bool
    logged_at: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

class ProgressLogCreate(BaseModel):
    profile_id: str
    plan_id: str
    day: int
    exercise_name: str
    completed: bool

class WeightEntry(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    profile_id: str
    weight: float
    logged_at: str = Field(default_factory=lambda: datetime.now(timezone.utc).isoformat())

class WeightEntryCreate(BaseModel):
    profile_id: str
    weight: float

class BMRResponse(BaseModel):
    bmr: float
    tdee: float  # Total Daily Energy Expenditure
    activity_level: str

# ==================== HELPER FUNCTIONS ====================

def calculate_bmr(weight: float, height: float, age: int, gender: str) -> float:
    """Calculate Basal Metabolic Rate using Mifflin-St Jeor Equation"""
    if gender.lower() == "male":
        return (10 * weight) + (6.25 * height) - (5 * age) + 5
    else:
        return (10 * weight) + (6.25 * height) - (5 * age) - 161

async def generate_plan_with_llm(profile: UserProfile, duration_days: int, intensity: str) -> Dict:
    """Generate workout and nutrition plan using LLM"""
    try:
        chat = LlmChat(
            api_key=EMERGENT_LLM_KEY,
            session_id=f"plan-gen-{profile.id}",
            system_message="You are an expert fitness coach and nutritionist. Generate personalized workout and nutrition plans in JSON format."
        ).with_model("openai", "gpt-5.2")

        bmr = calculate_bmr(profile.weight, profile.height, profile.age, profile.gender)
        tdee = bmr * 1.55  # Moderate activity

        prompt = f"""
Generate a {duration_days}-day personalized fitness and nutrition plan for:

Profile:
- Name: {profile.name}
- Age: {profile.age}
- Weight: {profile.weight}kg
- Height: {profile.height}cm
- Gender: {profile.gender}
- Health Conditions: {', '.join(profile.conditions) if profile.conditions else 'None'}
- Goals: {', '.join(profile.goals) if profile.goals else 'General fitness'}
- BMR: {bmr:.0f} calories
- TDEE: {tdee:.0f} calories
- Intensity: {intensity}

IMPORTANT: Respond ONLY with valid JSON in this exact format:
{{
  "workout_plan": [
    {{
      "day": 1,
      "focus": "Upper Body",
      "exercises": [
        {{
          "name": "Push-ups",
          "sets": 3,
          "reps": "10-12",
          "rest": "60 seconds",
          "instructions": "Keep your back straight. Lower your chest to the ground. Push back up."
        }}
      ]
    }}
  ],
  "nutrition_plan": [
    {{
      "day": 1,
      "breakfast": "Oatmeal with berries and almonds",
      "lunch": "Grilled chicken salad with quinoa",
      "dinner": "Baked salmon with roasted vegetables",
      "snacks": ["Greek yogurt", "Apple with peanut butter"],
      "total_calories": 2000,
      "protein": 150,
      "carbs": 200,
      "fat": 60
    }}
  ]
}}

Consider the health conditions and adjust accordingly. Provide clear, step-by-step instructions for each exercise.
"""

        user_message = UserMessage(text=prompt)
        response = await chat.send_message(user_message)

        # Parse JSON response
        response_text = response.strip()
        if response_text.startswith("```json"):
            response_text = response_text[7:]
        if response_text.startswith("```"):
            response_text = response_text[3:]
        if response_text.endswith("```"):
            response_text = response_text[:-3]
        
        plan_data = json.loads(response_text.strip())
        return plan_data

    except Exception as e:
        logging.error(f"LLM generation error: {str(e)}")
        # Fallback to simple default plan
        return generate_default_plan(profile, duration_days)

def generate_default_plan(profile: UserProfile, duration_days: int) -> Dict:
    """Fallback plan if LLM fails"""
    workout_plan = []
    nutrition_plan = []
    
    focuses = ["Full Body", "Upper Body", "Lower Body", "Cardio", "Core"]
    
    for day in range(1, duration_days + 1):
        focus = focuses[(day - 1) % len(focuses)]
        workout_plan.append({
            "day": day,
            "focus": focus,
            "exercises": [
                {
                    "name": "Push-ups",
                    "sets": 3,
                    "reps": "10-12",
                    "rest": "60 seconds",
                    "instructions": "Start in plank position. Lower chest to ground. Push back up."
                },
                {
                    "name": "Squats",
                    "sets": 3,
                    "reps": "12-15",
                    "rest": "60 seconds",
                    "instructions": "Stand with feet shoulder-width apart. Lower hips back and down. Return to standing."
                }
            ]
        })
        
        nutrition_plan.append({
            "day": day,
            "breakfast": "Oatmeal with fruits",
            "lunch": "Grilled chicken with vegetables",
            "dinner": "Fish with brown rice",
            "snacks": ["Greek yogurt", "Almonds"],
            "total_calories": 2000,
            "protein": 140,
            "carbs": 220,
            "fat": 65
        })
    
    return {
        "workout_plan": workout_plan,
        "nutrition_plan": nutrition_plan
    }

# ==================== ROUTES ====================

@api_router.get("/")
async def root():
    return {"message": "AroMi AI Agent API"}

# Profile Management
@api_router.post("/profiles", response_model=UserProfile)
async def create_profile(profile_data: ProfileCreate):
    profile = UserProfile(**profile_data.model_dump())
    await db.profiles.insert_one(profile.model_dump())
    return profile

@api_router.get("/profiles", response_model=List[UserProfile])
async def get_profiles():
    profiles = await db.profiles.find({}, {"_id": 0}).to_list(1000)
    return profiles

@api_router.get("/profiles/{profile_id}", response_model=UserProfile)
async def get_profile(profile_id: str):
    profile = await db.profiles.find_one({"id": profile_id}, {"_id": 0})
    if not profile:
        raise HTTPException(status_code=404, detail="Profile not found")
    return profile

@api_router.put("/profiles/{profile_id}", response_model=UserProfile)
async def update_profile(profile_id: str, update_data: ProfileUpdate):
    profile = await db.profiles.find_one({"id": profile_id}, {"_id": 0})
    if not profile:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    update_dict = {k: v for k, v in update_data.model_dump().items() if v is not None}
    if update_dict:
        await db.profiles.update_one({"id": profile_id}, {"$set": update_dict})
    
    updated_profile = await db.profiles.find_one({"id": profile_id}, {"_id": 0})
    return updated_profile

@api_router.delete("/profiles/{profile_id}")
async def delete_profile(profile_id: str):
    result = await db.profiles.delete_one({"id": profile_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Profile not found")
    return {"message": "Profile deleted successfully"}

# Plan Generation
@api_router.post("/generate-plan")
async def generate_plan(request: PlanGenerationRequest):
    profile_data = await db.profiles.find_one({"id": request.profile_id}, {"_id": 0})
    if not profile_data:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    profile = UserProfile(**profile_data)
    plan_data = await generate_plan_with_llm(profile, request.duration_days, request.workout_intensity)
    
    workout_plan = None
    nutrition_plan = None
    
    if request.include_workout and "workout_plan" in plan_data:
        daily_workouts = [
            DailyWorkout(
                day=day_data["day"],
                focus=day_data["focus"],
                exercises=[Exercise(**ex) for ex in day_data["exercises"]]
            )
            for day_data in plan_data["workout_plan"]
        ]
        workout_plan = WorkoutPlan(
            profile_id=request.profile_id,
            duration_days=request.duration_days,
            daily_workouts=daily_workouts
        )
        await db.workout_plans.insert_one(workout_plan.model_dump())
    
    if request.include_nutrition and "nutrition_plan" in plan_data:
        daily_meals = [
            DailyMeal(**meal_data)
            for meal_data in plan_data["nutrition_plan"]
        ]
        nutrition_plan = NutritionPlan(
            profile_id=request.profile_id,
            duration_days=request.duration_days,
            daily_meals=daily_meals
        )
        await db.nutrition_plans.insert_one(nutrition_plan.model_dump())
    
    return {
        "workout_plan": workout_plan.model_dump() if workout_plan else None,
        "nutrition_plan": nutrition_plan.model_dump() if nutrition_plan else None
    }

@api_router.get("/plans/{profile_id}")
async def get_plans(profile_id: str):
    workout_plans = await db.workout_plans.find({"profile_id": profile_id}, {"_id": 0}).sort("created_at", -1).to_list(10)
    nutrition_plans = await db.nutrition_plans.find({"profile_id": profile_id}, {"_id": 0}).sort("created_at", -1).to_list(10)
    
    return {
        "workout_plans": workout_plans,
        "nutrition_plans": nutrition_plans
    }

@api_router.get("/plans/{profile_id}/latest")
async def get_latest_plan(profile_id: str):
    workout_plan = await db.workout_plans.find_one({"profile_id": profile_id}, {"_id": 0}, sort=[("created_at", -1)])
    nutrition_plan = await db.nutrition_plans.find_one({"profile_id": profile_id}, {"_id": 0}, sort=[("created_at", -1)])
    
    return {
        "workout_plan": workout_plan,
        "nutrition_plan": nutrition_plan
    }

# Progress Tracking
@api_router.post("/progress", response_model=ProgressLog)
async def log_progress(log_data: ProgressLogCreate):
    progress_log = ProgressLog(**log_data.model_dump())
    await db.progress_logs.insert_one(progress_log.model_dump())
    return progress_log

@api_router.get("/progress/{profile_id}", response_model=List[ProgressLog])
async def get_progress(profile_id: str, plan_id: Optional[str] = None):
    query = {"profile_id": profile_id}
    if plan_id:
        query["plan_id"] = plan_id
    
    logs = await db.progress_logs.find(query, {"_id": 0}).sort("logged_at", -1).to_list(1000)
    return logs

# Weight Tracking
@api_router.post("/weight", response_model=WeightEntry)
async def add_weight_entry(entry_data: WeightEntryCreate):
    weight_entry = WeightEntry(**entry_data.model_dump())
    await db.weight_history.insert_one(weight_entry.model_dump())
    
    # Update profile's current weight
    await db.profiles.update_one(
        {"id": entry_data.profile_id},
        {"$set": {"weight": entry_data.weight}}
    )
    
    return weight_entry

@api_router.get("/weight/{profile_id}", response_model=List[WeightEntry])
async def get_weight_history(profile_id: str):
    entries = await db.weight_history.find({"profile_id": profile_id}, {"_id": 0}).sort("logged_at", 1).to_list(1000)
    return entries

# BMR Calculator
@api_router.get("/bmr/{profile_id}", response_model=BMRResponse)
async def get_bmr(profile_id: str, activity_level: str = "moderate"):
    profile_data = await db.profiles.find_one({"id": profile_id}, {"_id": 0})
    if not profile_data:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    profile = UserProfile(**profile_data)
    bmr = calculate_bmr(profile.weight, profile.height, profile.age, profile.gender)
    
    # Activity multipliers
    multipliers = {
        "sedentary": 1.2,
        "light": 1.375,
        "moderate": 1.55,
        "active": 1.725,
        "very_active": 1.9
    }
    
    tdee = bmr * multipliers.get(activity_level, 1.55)
    
    return BMRResponse(
        bmr=round(bmr, 2),
        tdee=round(tdee, 2),
        activity_level=activity_level
    )

# Include the router in the main app
app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()